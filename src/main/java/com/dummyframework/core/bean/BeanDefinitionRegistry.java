package com.dummyframework.core.bean;

import java.util.HashMap;
import java.util.Map;
import com.dummyframework.logger.Logger;
import com.dummyframework.utils.FrameworkUtils;

public class BeanDefinitionRegistry {

  Logger LOG = new Logger(getClass());

  private static BeanDefinitionRegistry INSTANCE = null;

  private BeanDefinitionRegistry() {
  }

  public static BeanDefinitionRegistry getInstance() {
    if (INSTANCE == null) {
      INSTANCE = new BeanDefinitionRegistry();
    }
    return INSTANCE;
  }

  // HashMap that stores all the bean where key is the name bean name generated by @getBeanName
  // method.
  private Map<String, BeanDefinition> beanDefinitionRegistry = new HashMap<>();

  /**
   * Generates a bean name as package.classname using BeanDefination, for example packageName =
   * 'com.example' and class name is 'Demo', so the resultant bean name will be com.example.Demo
   */
  private String generateBeanName(BeanDefinition definition) {
    return definition.getPackageName() + "." + definition.getClassName();
  }

  // Same as above, just uses Class<> instead of BeanDefination
  public String generateBeanName(Class<?> clazz) {
    return clazz.getPackageName() + "." + clazz.getSimpleName();
  }

  /**
   * Generates bean name and checks if bean's definition is already present in the registry. If yes,
   * then throws an exception as duplicate definitions will not be saved. If no, then bean
   * defination is save with key as bean name.
   * 
   * @param definition, takes defination to generate bean name.
   * @throws Exception
   */
  public void addToDefinitions(BeanDefinition definition) throws Exception {
    String beanName = generateBeanName(definition);
    if (hasBeanDefinition(beanName)) {
      LOG.debug("Bean definition with name '" + beanName + "' already present");
      return;
    }
    beanDefinitionRegistry.put(beanName, definition);
  }

  public int beanCount() {
    return beanDefinitionRegistry.size();
  }

  public boolean hasBeanDefinition(String beanName) {
    return beanDefinitionRegistry.containsKey(beanName);
  }

  public boolean hasBeanDefinition(Class<?> clazz) {
    return hasBeanDefinition(generateBeanName(clazz));
  }

  /**
   * Uses class to generate bean name and return bean's definition from registry. If the class
   * provided is an interface then the entire registry is searched for a class that implements the
   * given interface and is a primary bean. If multiple primary bean is found then the first in the
   * registry is returned. If there is no primary bean or there is no class implementing the given
   * interface then null is returned.
   * 
   * @param clazz
   * @return
   */
  public BeanDefinition getBeanDefinition(Class<?> clazz) {
    if (clazz.isInterface()) {
      for (BeanDefinition implementingClassDefinition : beanDefinitionRegistry.values()) {
        for (Class<?> implementedInterface : implementingClassDefinition
            .getImplementedInterfaces()) {
          if (implementedInterface == clazz && implementingClassDefinition.isPrimaryBean())
            return implementingClassDefinition;
        }
      }
      LOG.error("No primary bean definitaion found implementing interface "
          + FrameworkUtils.className(clazz) + " or not implementation is present.");
      return null;
    }
    return getBeanDefinition(generateBeanName(clazz));
  }

  // Checks is bean with @param beanName is present or not, if no the returns null else returns the
  // bean's definition.
  public BeanDefinition getBeanDefinition(String beanName) {
    if (!hasBeanDefinition(beanName)) {
      return null;
    }
    return beanDefinitionRegistry.get(beanName);
  }
}
